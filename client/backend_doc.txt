Frontend Integration Guide (API Reference)
=========================================

This document lists every REST + WebSocket primitive the frontend needs to fully mirror the multi-agent workflow, including the continuation flow and container/file controls.

1. Authentication & Setup
-------------------------
* Register: `POST /api/auth/register/` (body: `{"email":"","password":"","name":""}`)
* Login: `POST /api/auth/login/` (returns `access` + `refresh`)
* Authenticated REST calls must send `Authorization: Bearer <access>`.
* WebSocket auth:
  * Preferred: send cookies/headers.
  * Dev fallback: `ws://<host>:8000/ws/jobs/<job_id>/?token=<access>` works when `ALLOW_WS_TOKEN_QUERY=true`.

2. Job Lifecycle REST APIs
--------------------------
| Method | Path | Purpose |
| ------ | ---- | ------- |
| POST | `/api/jobs/` | Create a job. Body `{"prompt":"...idea..."}`. Response includes `id` and initial status `collecting`. Immediately triggers the first agent reply. |
| GET | `/api/jobs/` | List all jobs for the current user (descending by `created_at`). Use to populate dashboard. |
| GET | `/api/jobs/<job_id>/` | Detailed job snapshot, including stored steps/messages. Call on page load and after reconnect. |
| PATCH | `/api/jobs/<job_id>/` | Update `initial_prompt` while `status === collecting`. Body `{"initial_prompt": "new text"}`; backend mirrors `prompt`. |
| DELETE | `/api/jobs/<job_id>/` | Remove a single job. Best effort stops its Docker container. |
| DELETE | `/api/jobs/purge/` | Dev-only nuke for all of the user’s jobs (guarded by `ALLOW_JOB_PURGE`). |

3. Chat History APIs
--------------------
Used to hydrate transcripts after reconnect.

| Method | Path | Notes |
| ------ | ---- | ----- |
| GET | `/api/job-messages/?job_id=<job_id>` | Returns ordered chat history. Use immediately after login or when WebSocket drops. |
| GET | `/api/job-messages/<message_id>/` | Fetch a single message if you need random access. |
| POST | `/api/job-messages/` | Mostly admin/dev tooling; regular chat should go via WebSocket. |
| DELETE | `/api/job-messages/<id>/` | Dev/admin cleanup. |

4. Continuation (“continue thingy”)
----------------------------------
Allows adding new requirements after the first build completes.

* Endpoint: `POST /api/jobs/<job_id>/continue/`
* Body: `{"requirements":"Add PDF export ..."}`
* Behavior: returns `202 Accepted {"detail":"Continuation queued."}` and enqueues BA -> exec -> PM -> builder pipeline again.
* Guard rails: backend rejects if the job is still running or another continuation is in progress.
* Progress: streamed over the same WebSocket (chat/status/ticket updates). Re-fetch job detail to see the updated summary/messages.

5. WebSocket Protocol (chat through build completion)
-----------------------------------------------------
* URL: `ws://<host>:8000/ws/jobs/<job_id>/`
* Events (each payload has `kind`):
  * `stageUpdate`: conversational message (`role`, `sender`, `content`, `metadata.stage`). Includes both human chat and system descriptions.
  * `jobStatus`: lifecycle updates (`status` ∈ `collecting`, `queued`, `planning`, `prd_ready`, `ticketing`, `tickets_ready`, `building`, `build_done`, `failed`).
  * `agentDialogue`: CEO/CTO/Secretary discussion turns (display in timeline).
  * `prdReady`: PRD/spec is ready; also persisted to `App`.
  * `ticketUpdate`: ticket execution feed (`ticketId`, `status`, `title`, `assignedTo`, optional metadata/logs).
  * `ticketReset`: emitted right before a new backlog snapshot is persisted; refetch `/api/tickets/?job_id=...` when seen.
  * `error`: backend couldn’t parse/accept the incoming payload.
* Client → server: send `{"kind":"chat","content":"..."}` to talk to Client Relations while status is `collecting`. After that phase, the backend ignores chat payloads.

6. Ticket & Build APIs
----------------------
| Method | Path | Description |
| ------ | ---- | ----------- |
| GET | `/api/tickets/?job_id=<job_id>` | Snapshot of persisted tickets (epics + stories). Call once after `tickets_ready` and whenever you see a `ticketReset` event. |
| GET | `/api/tickets/<ticket_id>/` | Single ticket details (if you need to render drill-down). |

7. Container Control + File Browsing
------------------------------------
These APIs let the frontend start the per-job workspace container and browse files for preview.

| Method | Path | Usage |
| ------ | ---- | ----- |
| POST | `/api/jobs/<job_id>/containers/start` | Start/restart the Docker container tied to the job. Returns `{"detail":"Job container is running."}` when successful. Use when a user opens the “Files” tab or wants to interact with the dev server. |
| POST | `/api/jobs/<job_id>/containers/stop` | Gracefully stop the container. Call when closing the job or freeing resources. |
| GET | `/api/jobs/<job_id>/files/structure/?path=/app&limit=200` | Returns a directory tree rooted at `/app`. Use for file explorer UIs. `limit` caps how many entries get inspected (1–1000). |
| GET | `/api/jobs/<job_id>/files/content/?path=/app/src/App.tsx` | Streams file contents (UTF-8 text). Use to show code previews; path is sandboxed to `/app`. |
| POST | `/api/jobs/<job_id>/files/save` | Body: `{"path":"/app/src/App.tsx","content":"new text","encoding":"utf-8"}`. Persists edits inside the job container (max ~512 KB per request). Returns `{path, bytes_written, size, modified_at}`. |

8. Working End-to-End
---------------------
1. **Create job** via `POST /api/jobs/`.
2. **Load details** (`GET /api/jobs/<id>/`) and **connect WS** to stream chat/status.
3. **Render chat**:
   * Use REST history for initial messages.
   * Append `stageUpdate` events as they arrive.
   * Keep the input enabled until `jobStatus` > `collecting`.
4. **Monitor statuses** (`jobStatus`, `agentDialogue`, `prdReady`).
5. **Tickets**:
   * After `tickets_ready`, call `/api/tickets/?job_id=...`.
   * Update ticket board on every `ticketUpdate`.
6. **Continuation**:
   * Show a button when `job.status` ∈ `{build_done, failed}`.
   * On click, POST to `/api/jobs/<id>/continue/`, then rely on the existing WS stream for progress.
7. **Containers/files**:
   * Start container when user opens the file view (`POST .../containers/start`).
   * Use structure/content endpoints to pull files.
   * Optional stop when user leaves the page.

9. Troubleshooting Tips
-----------------------
* WebSocket closes with `4001/4003/1008`: token missing/invalid → refresh login.
* `ticketReset` storm: fetch the latest tickets snapshot; builder is regenerating the backlog.
* Continuation rejected (`409`): either job still running or another continuation is queued—disable the button until status returns to `build_done` or `failed`.

With these REST+WS primitives the frontend can replicate the entire agent experience: requirements chat, executive updates, PRD handoff, ticket execution, continuation requests, and Docker file inspection. Reach out if you need sample hooks or mocked payloads.