Frontend Integration Guide
1. Authentication
All endpoints + WebSocket connections require a JWT access token issued by the existing auth API.
Register: POST /api/auth/register/
Login: POST /api/auth/login/
Use the access token in Authorization: Bearer <token> for every HTTP request.
For WebSockets, send the same header if your client supports it. While ALLOW_WS_TOKEN_QUERY=true (dev mode), you can also append ?token=<access_token> to the WS URL for testing.
2. Job Lifecycle Overview
User submits an “idea” via POST /api/jobs/ – this stores a job in status collecting and immediately triggers the first Client Relations agent reply.
The frontend connects to the job’s WebSocket channel and renders the chat + subsequent statuses in real time.
Once the agent emits REQUIREMENTS_SUMMARY, the backend flips the job to queued and enqueues the Celery task; the executive build phase runs asynchronously and streams status/step/app events over the same socket.
The frontend can query REST endpoints any time to reconcile state (jobs, messages, final app artifact).
3. REST APIs
3.1 Jobs
Method	Path	Description
POST	/api/jobs/	Create a job. Body: {"prompt":"Initial idea..."}. Response contains job id.
GET	/api/jobs/	List jobs for the current user (most recent first).
GET	/api/jobs/<job_id>/	Job detail with steps and messages.
PATCH	/api/jobs/<job_id>/	Update initial_prompt while status is collecting. (Keeps prompts in sync.)
DELETE	/api/jobs/<job_id>/	Delete a single job (user-owned).
DELETE	/api/jobs/purge/	Dev only (guarded by ALLOW_JOB_PURGE) – delete all jobs for the current user.
3.2 Job Messages
These endpoints mirror the WebSocket transcript so the UI can load history on reconnect.
Method	Path	Usage
GET	/api/job-messages/?job_id=<job_id>	List messages (oldest → newest) for a job.
GET	/api/job-messages/<message_id>/	Fetch a single message.
POST	/api/job-messages/	Programmatically add a message (rare; mostly for admin/dev tooling). Body: {"job_id":"…","role":"user|agent|system","sender":"Name","content":"..."}.
DELETE	/api/job-messages/<message_id>/	Remove a message (again, mostly for dev/admin).
In normal operation the WebSocket handles chat creation; REST listing is primarily for “load on reconnect”.
3.3 Apps (final artifacts)
Method	Path	Description
GET	/api/apps/	List apps owned by the user.
GET	/api/apps/<app_id>/	Retrieve one app.
GET	/api/apps/by-job/<job_id>/	Fetch the app belonging to a specific job (204 if job finished but no app yet).
4. WebSocket Protocol
URL:
ws://<host>:8000/ws/jobs/<job_id>/
Headers: Authorization: Bearer <token>
For dev/testing, ws://<host>:8000/ws/jobs/<job_id>/?token=<token> also works.
Message Types from server (payload.kind):
Kind	Payload fields	Meaning
chat	role, sender, content, metadata, timestamp	A conversation turn from user or agent. Every new message is also persisted.
status	jobId, status, message, timestamp	High-level job status change (queued, running, done, failed).
step	jobId, agent, message, order, timestamp	Executive discussion turn (CEO/CTO/Secretary).
app	jobId, status, spec, timestamp	Final artifact has been stored (includes requirements, discussion history, PRD summary).
error	message	Validation errors on incoming client payloads (e.g., malformed JSON).
Messages from client → server:
Only kind="chat" is currently supported.
The backend derives the sender info from the authenticated user.
The message is persisted via JobMessage, broadcast to all connected clients, and forwarded to the requirements gatherer while the job is in collecting.
5. Frontend Flow
5.1 On page load / job view:
Fetch job list (GET /api/jobs/).
When the user opens a job detail:
Fetch job detail (GET /api/jobs/<id>/) to get steps + messages snapshot.
Connect WebSocket to /ws/jobs/<id>/ with JWT.
Render existing messages (from REST) in chronological order.
Listen for live chat, status, step, and app events and merge them into state.
Allow user to send new chat messages via WS by posting {"kind":"chat","content":"..."}.
5.2 After requirements summary:
You’ll see status switch to queued and a chat message containing the summary.
Keep the socket open; soon you’ll receive status → running and a sequence of step events from the CEO/CTO/Secretary.
When the job is done, you’ll get an app payload with the spec. Optionally call GET /api/apps/by-job/<id>/ for the stored artifact.
5.3 Handling reconnects:
Always read from /api/job-messages/?job_id=<id> when reconnecting so the chat history matches state before the WS was reopened.
Keep track of job.status. If it’s still collecting, you can continue sending chat events. Once it transitions to queued/running, disable the input (the gatherer phase is over).
6. Dev/Testing Tips
.envtemplate exposes ALLOW_WS_TOKEN_QUERY and ALLOW_JOB_PURGE (default True in DEBUG). In production, set them to False.
To start from a clean state during development: DELETE /api/jobs/purge/.
For quick REST smoke tests:
WebSocket testing via Postman:
URL: ws://localhost:8000/ws/jobs/<id>/?token=<token>
Message type: Text
JSON body: {"kind":"chat","content":"Here are more details..."}
With this flow the frontend can bootstrap state from REST, stream live updates via WS, and rely on the same JobMessage store for both. Let me know if you need a Postman collection or example React hooks for handling the socket.